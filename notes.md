## Why?

* pages load faster
  * saves one or more HTTP connections over pure client side rendering
  * saves re-loading or re-validating all static assets over pure server side rendering
  * HTTP I/O is the bottleneck – do as little as possible
* SEO optimization
  * pages can be scraped by spiders / bots
  * URLs are copy-pasteable

## History

* [Improving performance on twitter.com](https://blog.twitter.com/2012/improving-performance-on-twittercom)
  * May 2012 (almost exactly 2 years ago)
* [Isomorphic JavaScript: The Future of Web Apps](http://nerds.airbnb.com/isomorphic-JavaScript-future-web-apps/)
  * [Spike Brehm](https://twitter.com/spikebrehm), AirBnB
  * November 2013
  * Amazon claims each 100ms saved on page load = 1% increase in revenue
  * Twitter spent 1 year and 40 engineers implementing server-side rendering
* JavaScript History API, hashbang URLs, etc.
* Often touted as an advantage of Node as code can be shared between client and server
  * We now have Nashorn (Java 8+) and the ScriptEngine API (Java 6+) on the JVM
* Isomorphic frameworks
  * Mojito (Yahoo)
  * Meteor
  * [Derby](http://derbyjs.com/)
  * AirBnB's [Rendr](https://github.com/airbnb/rendr)
  * Artsy's [Ezel](http://ezeljs.com/)

## Handlebars plugin

* Used this on _Grails for Hipsters_
  * Used Grunt to compile Handlebars templates
  * We can now do this very easily in Grails using _handlebars-asset-pipeline_
* Incompatible with *asset-pipeline*
* It's pretty simple & just a wrapper round Handlebars-java

## Handlebars-java

* Handlebars templates are not retained by *handlebars-asset-pipeline* after compilation
* Not bundled into .war file
* Could duplicate but that would defeat the point
* JavaScript helpers *are* compatible

## Nashorn

* Can load the compiled template file generated by *asset-pipeline*
* Can share the exact same helpers as in the browser
* Java 8+ only
* Fall back to Rhino in Java <= 7 but more difficult to deal with model
  * Nashorn can deal with POJOs
  * Rhino needs you to render out as JSON and parse using JavaScript

        def json = scriptEngine.eval("JSON")
        def jsonStr = new JsonBuilder(model).toString()
        (scriptEngine as Invocable).invokeMethod(json, "parse", jsonStr)

## Implementation

* Duplication of routes between UrlMappings and client side route handler
* Models are just JSON on client

## Angular

* Different relationship between view and code
	* in Backbone / Ember code is responsible for rendering the view
	* in Angular HTML is the source of truth and it pulls in the rendering via directives
* not amenable to server-side rendering
* can use a PhantomJS proxy but it's more difficult than it seems
* best solution is to "pre-seed" data as a JSON block in the page
	* this avoids additional HTTP request(s) to retrieve data
	* really easy to do this with Angular as you can seed the $http cache
